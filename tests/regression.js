/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/* global describe,it,require */
/* jshint curly: false */

const
should = require('should'),
BrowserID = require('../'),
IdP = require('./lib/idp.js').IdP,
Client = require('./lib/client.js'),
jwcrypto = require('jwcrypto'),
fs = require('fs'),
path = require('path');

require("jwcrypto/lib/algs/rs");
require("jwcrypto/lib/algs/ds");

// This test validates several assertions generated by persona and IdPs.
// The idea is that we can excercise backwards compatibility
// best by ensuring that old assertions continue to validate (with modified
// current time and the proper public-key)
//
// This test harness reads the files in regression-cases/ and assumes each
// exports a set of properties.  Those properties contain the assertion, audience,
// public key, and assertion-specific tests.
describe('assertion regression tests', function() {
  // allocate a new client library hard-coded to serve a specific public-key
  // (over-ride HTTP fetches for well-known documents), and to verify assertions
  // as of a specific date.
  function mockedVerificationClient(pubKey, now, issuer, trustedIssuers) {
    issuer = issuer || 'login.persona.org';
    return new BrowserID({
      now: now,
      fallback: issuer,
      trustedIssuers: trustedIssuers,
      httpRequest: function(domain, path, cb) {
        if (issuer !== domain) return cb(null, 404);
        var doc = {
          'public-key': pubKey,
          'authentication': '/auth',
          'provisioning': '/auth',
        };
        cb(null, 200, { 'Content-Type': 'application/json' } , JSON.stringify(doc));
      }
    });
  }

  // extract a Date() from an assertion within it's validity period
  function validDate(assertion) {
    var d = jwcrypto.cert.unbundle(assertion);
    var expires = jwcrypto.extractComponents(d.signedAssertion).payload.iat;
    return new Date(expires - 60 * 1000);
  }

  var cases = [];
  var pathToCases = path.join(__dirname, 'regression-cases');
  fs.readdirSync(pathToCases).forEach(function(file) {
    if (!/^.*\.js$/.test(file)) return;
    cases.push(require(path.join(pathToCases, file)));
  });

  it('regression test cases should be read', function(done) {
    (cases.length).should.be.above(0);
    done();
  });

  // discover and run all of the regression test cases
  cases.forEach(function(c) {
    it(c.name, function(done) {
      var browserid = mockedVerificationClient(c.pubKey, validDate(c.assertion), c.issuer, c.trustedIssuers);
      browserid.verify({
        assertion: c.assertion,
        audience: c.audience
      }, function(err, details) {
        should.not.exist(err);
        (details.audience).should.equal(c.audience);
        if (c.email) (details.email).should.equal(c.email);
        (details.issuer).should.equal(c.issuer);
        // if additional idpClaims exist, test them here.
        if (c.idpClaims) {
          (details.idpClaims).should.exist;
          (details.idpClaims).should.be.type('object');
          Object.keys(c.idpClaims).forEach(function(claim) {
            details.idpClaims.should.have.property(claim);
            details.idpClaims[claim].should.equal(c.idpClaims[claim]);
          });
        }
        done(err);
      });
    });
  });
});
